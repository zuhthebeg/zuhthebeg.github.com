<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ìˆ«ì í¼ì¦ ê²Œì„</title>
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="icons/icon.svg">
    <meta name="theme-color" content="#2c3e50">
    <style>
        :root {
            --main-color: #2c3e50;
            --correct-color: #27ae60;
            --empty-color: #34495e;
            --text-color: #ecf0f1;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            font-family: 'Malgun Gothic', sans-serif;
            background: #2c3e50;
            touch-action: manipulation;
            padding: 10px;
        }

        #game-container {
            width: 100%;
            max-width: 500px;
            margin: 10px auto;
        }

        #controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            align-items: center;
        }

        select, button {
            padding: 8px 12px;
            font-size: 14px;
            border: none;
            border-radius: 4px;
            background: #3498db;
            color: white;
            cursor: pointer;
            flex: 1;
        }

        button {
            max-width: 100px;
        }

        #stats {
            display: flex;
            justify-content: space-between;
            background: rgba(255,255,255,0.1);
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 15px;
            color: var(--text-color);
        }

        /* ì ìˆ˜íŒ ìŠ¤íƒ€ì¼ ì¶”ê°€ */
        #score-board {
            width: 100%;
            max-width: 500px;
            margin: 20px auto;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            padding: 15px;
            color: var(--text-color);
        }

        #score-board h3 {
            margin-bottom: 10px;
            text-align: center;
        }

        #high-scores {
            list-style: none;
        }

        #high-scores li {
            padding: 5px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            display: flex;
            justify-content: space-between;
        }

        #puzzle-board {
            display: grid;
            background: var(--main-color);
            gap: 2px;
            border-radius: 6px;
            overflow: hidden;
            touch-action: none;
            width: 100%;
            aspect-ratio: 1;
            position: relative;
        }

        .tile {
            display: flex;
            justify-content: center;
            align-items: center;
            background: #ecf0f1;
            font-size: 3.5rem;
            font-weight: bold;
            color: var(--main-color);
            transition: transform 0.3s ease;
            user-select: none;
            position: absolute;
            will-change: transform;
        }

        .tile.correct {
            background: var(--correct-color);
            color: var(--text-color);
        }

        .tile.empty {
            background: var(--empty-color);
            border: 2px dashed #95a5a6;
            opacity: 0.8;
        }

        @media (max-width: 480px) {
            .tile {
                font-size: 3rem;
            }
        }

        /* ìŠ¹ë¦¬ íŒì—… ìŠ¤íƒ€ì¼ ì¶”ê°€ */
        .win-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0,0,0,0.3);
            text-align: center;
            z-index: 1000;
            min-width: 280px;
            display: none;
            color: var(--main-color);
        }

        .win-popup h2 {
            font-size: 48px;
            margin-bottom: 15px;
            color: var(--correct-color);
        }

        .win-popup p {
            margin: 10px 0;
            font-size: 32px;
        }

        .win-popup button {
            margin-top: 15px;
            width: 100%;
            max-width: 200px;
        }

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 999;
            display: none;
        }

        #language-select {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 8px 12px;
            background: #3498db;
            border: none;
            color: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        #language-select option {
            background: white;
            color: #2c3e50;
        }

        /* íŒì—… ë‹«ê¸° ë²„íŠ¼ ìŠ¤íƒ€ì¼ ìˆ˜ì • */
        .popup-content {
            position: relative;
            padding: 30px;
        }
        #close-popup {
            position: absolute;
            top: 5px;
            right: 10px;
            font-size: 28px;
            padding: 0 8px;
            line-height: 1;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="controls">
            <select id="level-select">
                <option value="3" selected data-i18n="3x3">3x3</option>
                <option value="4" data-i18n="4x4">4x4</option>
                <option value="5" data-8n="5x5">5x5</option>
            </select>
            <button onclick="startNewGame()" data-i18n="new-game">ìƒˆê²Œì„</button>
        </div>
        <div id="stats">
            <div>â± <span id="timer">0</span><span data-i18n="seconds">ì´ˆ</span></div>
            <div>ğŸ”¢ <span id="moves">0</span><span data-i18n="moves">íšŒ</span></div>
        </div>
        <div id="puzzle-board"></div>
    </div>

    <!-- ìŠ¹ë¦¬ íŒì—… ì¶”ê°€ -->
    <div class="overlay" id="overlay"></div>
    <div class="win-popup" id="win-popup">
        <h2 data-i18n="congratulations">ğŸ‰ ì¶•í•˜!</h2>
        <p data-i18n="puzzle-completed">í´ë¦¬ì–´!</p>
        <p id="win-stats"></p>
        <button onclick="startNewGame()" data-i18n="start-new-game">ìƒˆ ê²Œì„ ì‹œì‘</button>
    </div>

    <div id="score-board">
        <h3 data-i18n="high-scores">ğŸ† ìµœê³  ê¸°ë¡</h3>
        <ul id="high-scores"></ul>
    </div>

    <select id="language-select" onchange="changeLanguage(this.value)">
        <option value="ko">í•œêµ­ì–´</option>
        <option value="en">English</option>
        <option value="zh">ç¹é«”ä¸­æ–‡</option>
    </select>

    <script>
    // ë‹¤êµ­ì–´ ë²ˆì—­ ë°ì´í„°
    const translations = {
        ko: {
            "3x3": "3x3",
            "4x4": "4x4",
            "5x5": "5x5",
            "new-game": "ìƒˆê²Œì„",
            "seconds": "ì´ˆ",
            "moves": "íšŒ",
            "congratulations": "ğŸ‰ ì¶•í•˜!!",
            "puzzle-completed": "í¼ì¦ ì™„ì„±!",
            "start-new-game": "ìƒˆ ê²Œì„ ì‹œì‘",
            "puzzle-size": "í¼ì¦",
            "high-scores": "ğŸ† ìµœê³  ê¸°ë¡",
            "no-scores": "ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤"
        },
        en: {
            "3x3": "3x3",
            "4x4": "4x4",
            "5x5": "5x5",
            "new-game": "New Game",
            "seconds": "sec",
            "moves": "moves",
            "congratulations": "ğŸ‰ Congratulations!",
            "puzzle-completed": "Puzzle Completed!",
            "start-new-game": "Start New Game",
            "puzzle-size": "Puzzle",
            "high-scores": "ğŸ† High Scores",
            "no-scores": "No scores yet"
        },
        zh: {
            "3x3": "3x3",
            "4x4": "4x4",
            "5x5": "5x5",
            "new-game": "æ–°éŠæˆ²",
            "seconds": "ç§’",
            "moves": "æ­¥",
            "congratulations": "ğŸ‰ æ­å–œï¼",
            "puzzle-completed": "æ‹¼åœ–å®Œæˆï¼",
            "start-new-game": "é–‹å§‹æ–°éŠæˆ²",
            "puzzle-size": "æ‹¼åœ–",
            "high-scores": "ğŸ† æœ€é«˜ç´€éŒ„",
            "no-scores": "æš«ç„¡ç´€éŒ„"
        }
    };

    let currentLanguage = 'ko';
    let currentLevel = 3;
    let moves = 0;
    let timer = 0;
    let timerInterval;
    let tiles = [];
    const board = document.getElementById('puzzle-board');
    let isAnimating = false;
    let isGameStarted = false;
    let isGameWon = false;  // ìŠ¹ë¦¬ ìƒíƒœë¥¼ ì €ì¥í•  í”Œë˜ê·¸ ì¶”ê°€

    // ì–¸ì–´ ë³€ê²½ í•¨ìˆ˜
    function changeLanguage(lang) {
        currentLanguage = lang;
        document.documentElement.lang = lang;
        updateTexts();
    }

    // í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
    function updateTexts() {
        const elements = document.querySelectorAll('[data-i18n]');
        elements.forEach(element => {
            const key = element.getAttribute('data-i18n');
            if (translations[currentLanguage][key]) {
                element.textContent = translations[currentLanguage][key];
            }
        });
    }

    // ê²Œì„ ì´ˆê¸°í™”
    function initGame(size) {
        currentLevel = size;
        resetGame();
        generateBoard(size);
        addEventListeners();
    }

    // ë³´ë“œ ìƒì„±
    function generateBoard(size) {
        board.style.gridTemplateColumns = `repeat(${size}, 1fr)`;
        board.innerHTML = '';
        tiles = [];
        
        // íƒ€ì¼ ìƒì„± ë° ë°°ì¹˜
        for(let i = 0; i < size * size; i++) {
            const tile = document.createElement('div');
            tile.style.width = `calc(${100/size}% - 2px)`;
            tile.style.height = `calc(${100/size}% - 2px)`;
            
            if(i === size * size - 1) {
                // ë§ˆì§€ë§‰ ìœ„ì¹˜ì— ë¹ˆ ì¹¸ ìƒì„±
                tile.className = 'tile empty';
            } else {
                tile.className = 'tile';
                tile.textContent = i + 1;
                tile.dataset.value = i + 1;
            }
            
            // ì´ˆê¸° ìœ„ì¹˜ ì„¤ì •
            const x = (i % size) * 100;
            const y = Math.floor(i / size) * 100;
            tile.style.transform = `translate(${x}%, ${y}%)`;
            
            board.appendChild(tile);
            tiles.push(tile);
        }
        
        // íƒ€ì¼ ì„ê¸° ì „ì— ì ì‹œ ëŒ€ê¸°
        setTimeout(() => {
            shuffleTiles();
        }, 100);
    }

    async function shuffleTiles() {
        const size = currentLevel;
        const lastIndex = size * size - 1;

        let solvable = false;
        let indices;
        
        while (!solvable) {
            // ë¹ˆ ì¹¸ì„ ì œì™¸í•œ íƒ€ì¼ë“¤ì˜ ì¸ë±ìŠ¤ë§Œ ì„ê¸°
            indices = Array.from({ length: lastIndex }, (_, i) => i);
            for (let i = indices.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [indices[i], indices[j]] = [indices[j], indices[i]];
            }

            // ë¹ˆ ì¹¸ì˜ ìœ„ì¹˜ ì°¾ê¸° (ì‹¤ì œë¡œ ë§ˆì§€ë§‰ì— ë°°ì¹˜ë˜ê¸° ì „ ìƒíƒœì—ì„œ)
            let emptyIndex = lastIndex; // ê¸°ë³¸ì ìœ¼ë¡œ ë§ˆì§€ë§‰ ìœ„ì¹˜
            let inversions = 0;

            // ì „í™˜ ìˆ˜(inversions) ê³„ì‚°
            for (let i = 0; i < indices.length - 1; i++) {
                for (let j = i + 1; j < indices.length; j++) {
                    if (indices[i] > indices[j]) inversions++;
                }
            }

            // ë¹ˆ ì¹¸ì˜ í–‰ ìœ„ì¹˜ë¥¼ ì˜¬ë°”ë¥´ê²Œ ì°¾ê¸°
            const emptyRow = Math.floor(emptyIndex / size);
            const emptyRowFromBottom = size - emptyRow;

            // í¼ì¦ í•´ê²° ê°€ëŠ¥ ì—¬ë¶€ íŒë‹¨
            solvable = size % 2 === 1
                ? inversions % 2 === 0
                : (emptyRowFromBottom % 2) !== (inversions % 2);
        }

        // ì„ì¸ ì¸ë±ìŠ¤ì— ë”°ë¼ íƒ€ì¼ ì¬ë°°ì¹˜
        const newTiles = [];
        for (let i = 0; i < lastIndex; i++) {
            const tile = tiles[indices[i]];
            const x = (i % size) * 100;
            const y = Math.floor(i / size) * 100;
            tile.style.transform = `translate(${x}%, ${y}%)`;
            newTiles.push(tile);
        }

        // ë¹ˆ ì¹¸ì„ í•­ìƒ ë§ˆì§€ë§‰ ìœ„ì¹˜ì— ë°°ì¹˜
        const emptyTile = tiles[lastIndex];
        const x = (lastIndex % size) * 100;
        const y = Math.floor(lastIndex / size) * 100;
        emptyTile.style.transform = `translate(${x}%, ${y}%)`;
        newTiles.push(emptyTile);

        tiles = newTiles;
    }


    // íƒ€ì¼ ì´ë™ ì²˜ë¦¬
    async function handleMove(clickedTile) {
        if(isAnimating || isGameWon) return;  // ìŠ¹ë¦¬ ìƒíƒœì¼ ë•ŒëŠ” ì´ë™ ë¶ˆê°€
        if(!isGameStarted) isGameStarted = true;
        
        const emptyTile = tiles.find(t => t.classList.contains('empty'));
        const clickedIndex = tiles.indexOf(clickedTile);
        const emptyIndex = tiles.indexOf(emptyTile);

        const {direction, distance} = getSlideDirection(clickedIndex, emptyIndex);
        if(!direction) return;

        const movePath = getMovePath(clickedIndex, emptyIndex, direction);
        if(movePath.length === 0) return;

        isAnimating = true;
        
        // íƒ€ì¼ ë°°ì—´ ì—…ë°ì´íŠ¸
        for(const {from, to} of movePath) {
            [tiles[from], tiles[to]] = [tiles[to], tiles[from]];
        }
        
        // ì‹œê°ì  ìœ„ì¹˜ ì—…ë°ì´íŠ¸
        tiles.forEach((tile, index) => {
            const x = (index % currentLevel) * 100;
            const y = Math.floor(index / currentLevel) * 100;
            tile.style.transform = `translate(${x}%, ${y}%)`;
        });

        await new Promise(resolve => setTimeout(resolve, 200));
        
        moves++;
        document.getElementById('moves').textContent = moves;
        updateTileStates();
        checkWin();
        isAnimating = false;
    }

    // ìŠ¬ë¼ì´ë“œ ë°©í–¥ ë° ê±°ë¦¬ ê³„ì‚°
    function getSlideDirection(clickedIndex, emptyIndex) {
        const clickedRow = Math.floor(clickedIndex / currentLevel);
        const clickedCol = clickedIndex % currentLevel;
        const emptyRow = Math.floor(emptyIndex / currentLevel);
        const emptyCol = emptyIndex % currentLevel;

        if(clickedRow === emptyRow) {
            return {
                direction: 'horizontal',
                distance: clickedCol - emptyCol
            };
        }
        if(clickedCol === emptyCol) {
            return {
                direction: 'vertical',
                distance: clickedRow - emptyRow
            };
        }
        return {direction: null};
    }

    // ì´ë™ ê²½ë¡œ ìƒì„±
    function getMovePath(clickedIndex, emptyIndex, direction) {
        const path = [];
        const step = direction === 'horizontal' 
            ? (clickedIndex > emptyIndex ? 1 : -1)
            : (clickedIndex > emptyIndex ? currentLevel : -currentLevel);
        
        // ì‹œì‘ ìœ„ì¹˜ë¶€í„° í´ë¦­í•œ íƒ€ì¼ê¹Œì§€ì˜ ëª¨ë“  íƒ€ì¼ì„ ì´ë™ ê²½ë¡œì— ì¶”ê°€
        for (let current = emptyIndex; 
             direction === 'horizontal' 
                ? (step > 0 ? current < clickedIndex : current > clickedIndex)
                : (step > 0 ? current < clickedIndex : current > clickedIndex); 
             current += step) {
            path.push({
                from: current + step,
                to: current
            });
        }
        
        return path;
    }

    // ì• ë‹ˆë©”ì´ì…˜ ìˆ˜í–‰
    function performSlideAnimation(movePath) {
        return new Promise(resolve => {
            // íƒ€ì¼ ë°°ì—´ ì—…ë°ì´íŠ¸
            for(const {from, to} of movePath) {
                [tiles[from], tiles[to]] = [tiles[to], tiles[from]];
            }
            
            // ì‹œê°ì  ìœ„ì¹˜ ì—…ë°ì´íŠ¸
            tiles.forEach((tile, index) => {
                const x = (index % currentLevel) * 100;
                const y = Math.floor(index / currentLevel) * 100;
                tile.style.transform = `translate(${x}%, ${y}%)`;
            });

            setTimeout(resolve, 200);
        });
    }

    // ë³´ë“œ ìœ„ì¹˜ ì—…ë°ì´íŠ¸
    function updateBoardPositions(shuffle = false) {
        tiles.forEach((tile, index) => {
            const x = (index % currentLevel) * 100;
            const y = Math.floor(index / currentLevel) * 100;
            if(shuffle) {
                tile.style.transition = 'none';
            }
            tile.style.transform = `translate(${x}%, ${y}%)`;
        });
        
        if(shuffle) {
            setTimeout(() => {
                tiles.forEach(tile => {
                    tile.style.transition = 'transform 0.2s ease';
                });
            }, 10);
        }
    }

    // íƒ€ì¼ ìƒíƒœ ì—…ë°ì´íŠ¸
    function updateTileStates() {
        tiles.forEach((tile, index) => {
            if(tile.classList.contains('empty')) return;
            const correctPos = parseInt(tile.dataset.value) === index + 1;
            tile.classList.toggle('correct', correctPos);
        });
    }

    // ìŠ¹ë¦¬ ì¡°ê±´ í™•ì¸
    function checkWin() {
        const isWin = tiles.every((tile, index) => 
            index === tiles.length - 1 || 
            (tile && parseInt(tile.dataset.value) === index + 1)
        );
        
        if(isWin) {
            isGameWon = true;  // ìŠ¹ë¦¬ ì‹œ í”Œë˜ê·¸ ì„¤ì •
            clearInterval(timerInterval);
            saveScore();
            updateHighScores();
            setTimeout(() => {
                const popup = document.getElementById('win-popup');
                const overlay = document.getElementById('overlay');
                const stats = document.getElementById('win-stats');
                
                stats.innerHTML = `
                    <strong>${currentLevel}x${currentLevel} ${translations[currentLanguage]["puzzle-size"]}</strong><br>
                    â± ${timer}${translations[currentLanguage]["seconds"]}<br>
                    ğŸ”¢ ${moves}${translations[currentLanguage]["moves"]}
                `;
                
                popup.style.display = 'block';
                overlay.style.display = 'block';
            }, 200);
        }
    }

    // ê²Œì„ ë¦¬ì…‹
    function resetGame() {
        moves = 0;
        timer = 0;
        isGameStarted = false;
        isGameWon = false;  // ê²Œì„ ë¦¬ì…‹ ì‹œ ìŠ¹ë¦¬ í”Œë˜ê·¸ ì´ˆê¸°í™”
        clearInterval(timerInterval);
        document.getElementById('moves').textContent = '0';
        document.getElementById('timer').textContent = '0';
        
        timerInterval = setInterval(() => {
            if(isGameStarted) {
                timer++;
                document.getElementById('timer').textContent = timer;
            }
        }, 1000);
    }

    // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
    function addEventListeners() {
        document.getElementById('level-select').addEventListener('change', (e) => {
            currentLevel = parseInt(e.target.value);
            initGame(currentLevel);
            updateHighScores();
        });

        let touchStartX = 0;
        let touchStartY = 0;
        let touchStartTime = 0;

        // í„°ì¹˜ ì´ë²¤íŠ¸ ì²˜ë¦¬
        board.addEventListener('touchstart', e => {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
            touchStartTime = Date.now();
            e.preventDefault();
        }, {passive: false});

        board.addEventListener('touchend', e => {
            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;
            const touchEndTime = Date.now();
            
            const dx = touchEndX - touchStartX;
            const dy = touchEndY - touchStartY;
            const duration = touchEndTime - touchStartTime;
            
            // ë¹ ë¥¸ íƒ­ ë™ì‘ ì²˜ë¦¬ (200ms ë¯¸ë§Œ)
            if (duration < 200 && Math.abs(dx) < 10 && Math.abs(dy) < 10) {
                const target = document.elementFromPoint(touchEndX, touchEndY);
                if(target?.classList.contains('tile') && !target.classList.contains('empty')) {
                    handleMove(target);
                }
                e.preventDefault();
                return;
            }

            // ìŠ¬ë¼ì´ë“œ ë™ì‘ ì²˜ë¦¬
            const minSwipeDistance = 30; // ìµœì†Œ ìŠ¬ë¼ì´ë“œ ê±°ë¦¬
            if (Math.abs(dx) > minSwipeDistance || Math.abs(dy) > minSwipeDistance) {
                const emptyTile = tiles.find(t => t.classList.contains('empty'));
                const emptyIndex = tiles.indexOf(emptyTile);
                const emptyRow = Math.floor(emptyIndex / currentLevel);
                const emptyCol = emptyIndex % currentLevel;
                
                // ìŠ¬ë¼ì´ë“œ ë°©í–¥ ê²°ì •
                let targetIndex = -1;
                if (Math.abs(dx) > Math.abs(dy)) {
                    // ìˆ˜í‰ ìŠ¬ë¼ì´ë“œ
                    if (dx > 0 && emptyCol > 0) { // ì˜¤ë¥¸ìª½ìœ¼ë¡œ ìŠ¬ë¼ì´ë“œ
                        targetIndex = emptyIndex - 1;
                    } else if (dx < 0 && emptyCol < currentLevel - 1) { // ì™¼ìª½ìœ¼ë¡œ ìŠ¬ë¼ì´ë“œ
                        targetIndex = emptyIndex + 1;
                    }
                } else {
                    // ìˆ˜ì§ ìŠ¬ë¼ì´ë“œ
                    if (dy > 0 && emptyRow > 0) { // ì•„ë˜ë¡œ ìŠ¬ë¼ì´ë“œ
                        targetIndex = emptyIndex - currentLevel;
                    } else if (dy < 0 && emptyRow < currentLevel - 1) { // ìœ„ë¡œ ìŠ¬ë¼ì´ë“œ
                        targetIndex = emptyIndex + currentLevel;
                    }
                }
                
                // ìœ íš¨í•œ ì´ë™ì´ë©´ ì²˜ë¦¬
                if (targetIndex >= 0 && targetIndex < tiles.length) {
                    handleMove(tiles[targetIndex]);
                }
            }
            e.preventDefault();
        }, {passive: false});

        // ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ ì²˜ë¦¬
        board.addEventListener('click', e => {
            const target = e.target;
            if(target.classList.contains('tile') && !target.classList.contains('empty')) {
                handleMove(target);
            }
        });
    }

    // ìƒˆ ê²Œì„ ì‹œì‘
    function startNewGame() {
        closeWinPopup();
        initGame(currentLevel);
        updateHighScores();
    }

    // ì ìˆ˜ ì €ì¥ í•¨ìˆ˜
    function saveScore() {
        const now = new Date();
        const scoreEntry = {
            date: `${now.getFullYear()}-${String(now.getMonth()+1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`,
            time: `${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}:${String(now.getSeconds()).padStart(2, '0')}`,
            moves: moves,
            seconds: timer,
            level: currentLevel
        };

        const storageKey = `puzzleScores-level${currentLevel}`;
        const scores = JSON.parse(localStorage.getItem(storageKey) || '[]');
        
        // ì¤‘ë³µ ê¸°ë¡ ë°©ì§€
        const isDuplicate = scores.some(entry => 
            entry.moves === moves && entry.seconds === timer
        );
        
        if (!isDuplicate) {
            scores.push(scoreEntry);
            scores.sort((a, b) => a.moves - b.moves || a.seconds - b.seconds);
            localStorage.setItem(storageKey, JSON.stringify(scores.slice(0, 5)));
        }
    }

    // ìµœê³  ê¸°ë¡ í‘œì‹œ ì—…ë°ì´íŠ¸
    function updateHighScores() {
        const storageKey = `puzzleScores-level${currentLevel}`;
        const scores = JSON.parse(localStorage.getItem(storageKey) || '[]');
        const list = document.getElementById('high-scores');
        list.innerHTML = '';

        if(scores.length === 0) {
            list.innerHTML = `<li>${translations[currentLanguage]["no-scores"]}</li>`;
            return;
        }

        scores.slice(0, 5).forEach(entry => {
            const li = document.createElement('li');
            li.innerHTML = `
                <span>${entry.date} ${entry.time}</span>
                <span>${entry.moves}${translations[currentLanguage]["moves"]} / ${entry.seconds}${translations[currentLanguage]["seconds"]}</span>
            `;
            list.appendChild(li);
        });
    }

    // íŒì—… ë‹«ê¸° ê¸°ëŠ¥ ê°œì„ 
    function closeWinPopup() {
        document.getElementById('win-popup').style.display = 'none';
        document.getElementById('overlay').style.display = 'none';
    }

    // ì˜¤ë²„ë ˆì´ í´ë¦­ ì‹œ íŒì—… ë‹«ê¸°
    document.getElementById('overlay').addEventListener('click', closeWinPopup);

    // íŒì—… ë‚´ìš© í´ë¦­ ì‹œ ì´ë²¤íŠ¸ ì „íŒŒ ë°©ì§€
    document.querySelector('.win-popup').addEventListener('click', function(e) {
        e.stopPropagation();
    });

    // ì´ˆê¸° ì‹¤í–‰
    initGame(3);

    // PWA ì„œë¹„ìŠ¤ ì›Œì»¤ ë“±ë¡
    if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
            navigator.serviceWorker.register('/service-worker.js')
                .then(registration => {
                    console.log('ServiceWorker ë“±ë¡ ì„±ê³µ:', registration.scope);
                })
                .catch(error => {
                    console.log('ServiceWorker ë“±ë¡ ì‹¤íŒ¨:', error);
                });
        });
    }

    // ì´ˆê¸° ì‹¤í–‰ ì‹œ ì–¸ì–´ ì„¤ì •
    document.addEventListener('DOMContentLoaded', () => {
        // ë¸Œë¼ìš°ì € ì–¸ì–´ ê°ì§€
        const browserLang = navigator.language.split('-')[0];
        const supportedLang = ['ko', 'en', 'zh'].includes(browserLang) ? browserLang : 'ko';
        
        document.getElementById('language-select').value = supportedLang;
        changeLanguage(supportedLang);
        updateHighScores();
    });
    </script>
</body>
</html>